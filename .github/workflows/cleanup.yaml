permissions:
  contents: read
  packages: write
name: Cleanup old untagged GHCR images.
on:
  schedule:
    # Runs weekly on Sunday at 00:00 UTC
    - cron: '0 0 * * 0'
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'If "true", perform a dry-run (no deletes). Manual runs default to dry-run for safety.'
        required: false
        default: 'true'
jobs:
  cleanup:
    name: Cleanup untagged GHCR images older than 30 days
    runs-on: ubuntu-latest
    # Ensure scheduled runs only execute on `main`; allow manual dispatch on any branch
    if: github.event_name == 'workflow_dispatch' || (github.event_name == 'schedule' && github.ref == 'refs/heads/main')
    env:
      IMAGE_NAME: framework-fedora-bootc
      # For scheduled runs DRY_RUN will be 'false'. For manual dispatch, the input controls it.
      DRY_RUN: ${{ (github.event_name == 'workflow_dispatch' && github.event.inputs.dry_run) || 'false' }}
    steps:
      - name: Checkout (for context)
        uses: actions/checkout@v6

      - name: Install jq
        run: |
          sudo apt-get update;
          sudo apt-get install -y jq
      - name: Gather candidate versions
        id: gather
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          OWNER: ${{ github.repository_owner }}
          PACKAGE: ${{ env.IMAGE_NAME }}
        run: |
          set -euo pipefail
          out=candidates.txt
          # Log uses id first (stable key); digest is included for visibility.
          printf '# id\tdigest\tcreated_at\tselected\n' > "$out"
          # Determine whether owner is an Organization or User
          owner_type=$(curl -s -H "Authorization: Bearer $GITHUB_TOKEN" "https://api.github.com/users/$OWNER" | jq -r '.type')
          if [ "$owner_type" = "Organization" ]; then
            base="orgs/$OWNER"
          else
            base="users/$OWNER"
          fi

          per_page=100
          page=1
          cutoff_ts=$(date -d "30 days ago" +%s)
          while :; do
            url="https://api.github.com/${base}/packages/container/${PACKAGE}/versions?per_page=${per_page}&page=${page}"
            resp=$(curl -s -H "Authorization: Bearer $GITHUB_TOKEN" -H "Accept: application/vnd.github+json" "$url")
            count=$(echo "$resp" | jq 'length')
            if [ "$count" -eq 0 ]; then
              break
            fi

            # For each version, decide whether it's a candidate:
            # - No tags => candidate
            # - Tags exist and ALL tags look like commit hashes (7-40 hex chars) => candidate
            # - Otherwise skip
            echo "$resp" | jq -c '.[]' | while read -r item; do
              id=$(echo "$item" | jq -r '.id')
              digest=$(echo "$item" | jq -r '.metadata.container.digest // empty')
              created=$(echo "$item" | jq -r '.created_at')
              created_ts=$(date -d "$created" +%s)

              # gather tags as space-separated list
              tags=$(echo "$item" | jq -r '.metadata.container.tags // [] | join(" ")')

              consider=false
              if [ -z "$tags" ]; then
                consider=true
              else
                # check whether ALL tags look like commit hashes (7-40 hex chars)
                all_hashes=true
                for t in $tags; do
                  if ! [[ "$t" =~ ^[0-9a-fA-F]{40}$ ]]; then
                    all_hashes=false
                    break
                  fi
                done
                if [ "$all_hashes" = true ]; then
                  consider=true
                fi
              fi

              if [ "$consider" = true ]; then
                if [ "$created_ts" -lt "$cutoff_ts" ]; then
                  selected=yes
                else
                  selected=no
                fi
                # Write id first (stable key), then digest, created, selected
                printf "%s\t%s\t%s\t%s\n" "$id" "$digest" "$created" "$selected" >> "$out"
              fi
            done

            page=$((page+1))
          done

          # Add a summary header with counts selected vs total
          total=$(tail -n +2 "$out" | wc -l | tr -d ' ')
          # selected is now the 4th column
          selected_count=$(tail -n +2 "$out" | awk -F $'\t' '$4=="yes"{c++}END{print c+0}')
          not_selected=$((total - selected_count))
          tmp="${out}.tmp"
          printf '# summary: selected=%s\tnot_selected=%s\ttotal=%s\n' "$selected_count" "$not_selected" "$total" > "$tmp"
          cat "$out" >> "$tmp"
          mv "$tmp" "$out"

          echo "Collected candidate versions (with summary):" 
          cat "$out"

      - name: Upload candidate list artifact
        uses: actions/upload-artifact@v6
        with:
          name: ghcr-candidates-${{ github.run_id }}
          path: candidates.txt

      - name: Post summary to PR (if running in a PR context)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          OWNER: ${{ github.repository_owner }}
          REPO: ${{ github.event.repository.name || github.repository }}
          RUN_ID: ${{ github.run_id }}
        run: |
          set -euo pipefail
          # Try to find a PR associated with this run/commit
          pr_number=""
          # First, check if event payload has pull_request
          if [ "${GITHUB_EVENT_NAME:-}" = "pull_request" ]; then
            pr_number=$(jq -r .pull_request.number < "$GITHUB_EVENT_PATH" || true)
          fi
          # If not found, try commits -> pulls API
          if [ -z "$pr_number" ]; then
            resp=$(curl -s -H "Authorization: Bearer $GITHUB_TOKEN" -H "Accept: application/vnd.github+json" "https://api.github.com/repos/${OWNER}/${REPO}/commits/${GITHUB_SHA}/pulls")
            pr_number=$(echo "$resp" | jq -r '.[0].number // empty')
          fi

          if [ -z "$pr_number" ]; then
            echo "No PR found for this run/commit; skipping PR comment."
            exit 0
          fi

          # Read the summary header from candidates.txt (first line)
          summary_line=$(head -n 1 candidates.txt || true)
          # Build the comment body with printf to avoid YAML/heredoc parsing issues in editors
          printf -v body 'Cleanup candidates summary (run %s):\n\n%s\n\nCandidate list artifact: ghcr-candidates-%s\n\nSee the artifact for the full list of candidate versions (id, created_at, selected).' \
            "$RUN_ID" "$summary_line" "$RUN_ID"

          echo "Posting summary to PR #${pr_number}"
          curl -s -X POST -H "Authorization: Bearer $GITHUB_TOKEN" -H "Accept: application/vnd.github+json" \
            -d "{\"body\": $(jq -Rn --arg str "$body" '$str') }" \
            "https://api.github.com/repos/${OWNER}/${REPO}/issues/${pr_number}/comments" > /dev/null

      - name: Perform deletions (reads candidate list)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          DRY_RUN: ${{ env.DRY_RUN }}
          PACKAGE: ${{ env.IMAGE_NAME }}
          OWNER: ${{ github.repository_owner }}
        run: |
          set -euo pipefail
          echo "DRY_RUN=${DRY_RUN}"
          # Use awk to safely parse TAB-separated fields (preserves empty fields)
          # and perform deletions (or dry-run messages). This avoids relying on shell IFS,
          # which can collapse multiple adjacent IFS whitespace characters.
          # Feed the awk program via heredoc to avoid shell/YAML mangling of quotes
          awk -F '\t' -f - candidates.txt <<'AWK' | bash -euo pipefail
          $0 ~ /^#/ || NF < 4 { next }
          id=$1; digest=$2; created=$3; selected=$4
          if (selected == "yes") {
            if (ENVIRON["DRY_RUN"] == "true") {
              printf "echo [dry-run] Would delete package version (id: %s) (digest: %s) (created: %s)\n", id, digest, created
            } else {
              printf "curl -s -X DELETE -H \"Authorization: Bearer %s\" -H \"Accept: application/vnd.github+json\" \"https://api.github.com/%s/packages/container/%s/versions/%s\"\n", ENVIRON["GITHUB_TOKEN"], ENVIRON["OWNER"], ENVIRON["PACKAGE"], id
            }
          } else {
            printf "echo Candidate (id: %s) (created: %s) is not older than 30 days; skipping\n", id, created
          }
          AWK
